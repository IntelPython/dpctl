= Data parallel control Python API specification (draft)
Diptorup Deb <diptorup.deb@intel.com>
v0.0
:source-highlighter: pygments
:icons: font

== Introduction

*_TODO_* Motivating paragraph about what issue we are addressing.

This document contains the specification of the data parallel control (dpCtl)
Python runtime. DpCtl provides a way for Python packages and extensions to
interact with SYCL, and to interoperate amongst each other by sharing SYCL
devices, queues and USM memory.

DpCtl has two main components that are described in this spec: a SYCL device
manager and a SYCL USM memory manager.

== Device manager

The dpCtl device manager exposes an API for Python applications and libraries to
interact with SYCL devices. The device manager supports the following main
functionalities:

- Ability to create a new SYCL device from a filter selector string, or a
  Python object wrapping an existing SYCL device.
- Create a sub-device from a SYCL device.
- A getter function to get a cached SYCL queue for a specific device.
- Ability to create a new SYCL queue from a device.
- Ability to get the SYCL context for a specific device.
- Getter functions for various (to be specified) device info attributes.

=== Creating a SYCL device

Dpctl provides a Python context manager `dpctl.device` to create a new SYCL
device.

[source,python]
----
# Creating a new SyclDevice using a string that abstracts a DPC++ filter
# selector.
with dpctl.device("opencl:gpu:0"):
    pass

# Creating a new SyclDevice from another Python object.
with dpctl.device(device_obj):
    pass
----

The `dpctl.device` context manager creates a new `dpctl.SyclDevice` object and
yields the object back to caller. In addition, it makes a queue corresponding
to that device the "activated queue", _i.e._, the queue returned by
`dpctl.get_current_queue()`. The queue and the device remain in scope for the
lifetime of the context manager. Note that dpCtl creates cached queues for each
device when the module is loaded and `dpctl.device` retrieves the cached queue
and does not create a new queue.

A possible implementation of the `dpctl.device` context manager can be:

[source,python]
----
@contextmanager
def device(inp):
    """
    Device received a filter spec, or an object that implement `__get_device__` method
    that either constructs `dpctl.SyclDevice` or provide a named "sycl_device" PyCapsule
    that carries a pointer to `sycl::device`.
    """
    if isinstance(inp, str):
        yield from_filter(inp)
    elif hasattr(inp, '__get_device__'):
        cdef object dev  = inp.__get_device__()
        if (isinstance(dev, dpctl.SyclDevice)):
            yield dev
        elif is_capsule(inp, expected_name):
            dev = device_from_capsule(inp)
            yield dev
    else:
        raise TypeError('')
----

The https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/FilterSelector/FilterSelector.adoc[DPC++ filter selector]
is a three-tuple specifying a SYCL backend, a SYCL device type, and a SYCL
device ID. Each component is optional, but at least one should be provided.

When a Python object is passed in to the `dpctl.device` context manager we can
use an existing object to create a

** Sub-devices**
The current filter selector proposal does not allow specifying sub-devices and
dpCtl can either provide a super set of the filter selector with a possible
fourth optional parameter to specify a sub device.

Another way to support sub-devices will be to expose the `create_sub_device()`
functionality of SYCL via dpCtl.



The `dpctl.device` returns a new `SyclDevice` object.

A `SYCLDevice` object has an API function to return a SYCL queue corresponding
to the underlying SYCL device.

[source,python]
----

with dpctl.device("opencl:gpu:0") as ocl_gpu0:
    q = ocl_gpu0.get_queue()
----

== Memory manager
